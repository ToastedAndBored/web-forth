# Task
Проект: web интерпретатор языка FORTH с визуальным отображением процесса работы

Должно получиться:
Страница разделенная по вертикали на три панели равной ширины:
- Панель с исходным кодом
- Панель отображающая два стека интерпретатора
- Панель отображающая вывод программы

Под панелями три кнопки
- Запустить интерпретацию
- Отсановить
- Сделать один шаг

Также присуствует счетчик выполненых комманд и счетчик, отображающий,
сколько всего слов в программе.

Пользователь может ввести произвольный forth код в левую панель и запустить
его на исполнение.
В процессе интерпретации, на левой панели слово исполняемое на текущем ходу
выделяется цветом.

На центральной панели друг за другом отображается содержимое стека данных,
стека вызовов интерпретатора и словарь объявленых программой слов.
При наведении курсора на значение в стеке вызовов, соответвующее слово на 
левой панели обводится в рамку (если таковое имеется).
Тоже верно для опредлений слов в словаре.
Переопредленные слова в словаре отображаются полу-прозрачными.

Правая панель содержит текст выводимый исполняемой программой.
В будущем, в качестве усложненной задачи, в правой панели также будет canvas
на котором выполняемый код сможет рисовать.

Layout итоговой страницы:
```
Code panel     Stack panel    Output panel
┌────────────┐ ┌────────────┐ ┌────────────┐
│;Some FORTH │ │data stack: │ │some text pr│
│dup dup     │ │a           │ │inted by scr│
│idk         │ │b           │ │ipt         │
│            │ │c           │ │            │
│            │ │d           │ │            │
│            │ │e           │ │            │
│            │ │            │ ├────────────┤
│            │ │call stack: │ │            │
│            │ │42          │ │    canv    │
│            │ │137         │ │            │
│            │ │69          │ │            │
│            │ │            │ │            │
│            │ │dictionary: │ │            │
│            │ │aaaa -> 12  │ │            │
└────────────┘ └────────────┘ └────────────┘
[Start button] [Stop button] [Next step button] [step counter] [words]
```
# FORTH
В этом проекте используется одна из вариаций языка FORTH
(отлчиная от оригинального форта)

## Syntax
- Текст на языке forth состоит из слов.
- Слова разделяются не значащими символами:
	- Пробел
	- Символ табуляции (`\t`)
	- Символ переноса строки (`\n`)
	- Символ возврата каретки (`\r`)
- Одинарные кавычки `'` объединяют несколько слов в одно
	- Такие слова называются `quotted words`
	- Внутри таких слов производится замена некоторых подстрок
		- `\\` на `\`
		- `\'` на `'`
		- `\n` на символ переноса строки
	- При этом сами кавычки, обрамляющие слово, удаляются
- Слова состоящие только из цифр являются числами
	- кроме `quotted` слов, они всегда строки

Таким образом следующий текст на forth:

```forth
  : a b c ; d e
f g 'a \n \n bb'
hijk l


m       n    145
```
Может быть преобразован в такую структуру:
```json
[
	{"origin": ":", "value": ":", "postfix": " ", "prefix": "  "},
	{"origin": "a", "value": "a", "postfix": " "},
	{"origin": "b", "value": "b", "postfix": " "},
	{"origin": "c", "value": "c", "postfix": " "},
	{"origin": ";", "value": ";", "postfix": " "},
	{"origin": "d", "value": "d", "postfix": " "},
	{"origin": "e", "value": "e", "postfix": "\n"},
	{"origin": "f", "value": "f", "postfix": " "},
	{"origin": "g", "value": "g", "postfix": " "},
	{"origin": "'a \\n \\n bb'", "text": "a \n \n bb", "postfix": "\n", "quotted": true},
	{"origin": "hjk", "value": "hjk", "postfix": " "},
	{"origin": "l", "value": "l", "postfix": "\n\n\n"},
	{"origin": "m", "value": "m", "postfix": "       "},
	{"origin": "n", "value": "n", "postfix": "    "},
	{"origin": "145", "value": 145, "postfix": ""},
]
```
Где
- `origin` - оригинальный текст слова (как и в исходном коде)
- `value` - значение слова после замены eascape-последовательностей
- `quotted` - флаг указывающий, было ли слово в исходном тексте в кавычках
- `postfix` - список незначащих символов которые шли после слова в исходном тексте (это нам понадобится для корректного выделеня слов в тексте цветом)
- `prefix` - список незначащих символов которые шли перед словом. Актуально только для первого слова в тексте

## FORTH Machine
Интерпретатор forth (aka `forth machine`) состоит из
- Списка слов в программе (см выше)
- Указателя на текущее слово (равен 0 в начале работы)
- Двух стеков
- Словаря команд

### Stacks
Два стека форт машины:
- Стек данных (он же левый, он же первый) далее СД
- Стек вызовов (он же правый, он же второй) далее СВ

В целом, оба стека можно использовать для хранения любых данных но, 
по соглашению, левый стек используется для хранения данных (переменные,
аргументы функций), а правый для сохранения адресов возврата.
Тем не менее многим словам(командам) может не хватать одного из стеков и
они могут использовать оба. Главное, такие слова должны полсе своего исполнения
вернуть состояния стеков обратно.

### Dict
Словарь содержит опредления слов.
При старте программы в нем содержится некоторое количество предопределенных
aka встроенных слов.
В процессе работы, программа может определять собственные слова (читай создавать функции)
Уже определенные слова можно временно переопредлеять, а затем возвращать
старое опредленеие.

Внутри словарь состоит по сути тоже из стека.
При опредлении слова, оно (опредление) добавляется на вершину стека.
При поиске слова в словаре, поик идет с веришны стека к его началу.
Таким образом временные переопредления слов тривиальны.

Встроенные слова:
- `.` - завершить программу
- `..` - забрать значение с СД, вывести его
- `+` - забрать два значения с СД, сложить, положить обратно результат
- `-` - то же, что и `+` но с вычитанием
- `*` - то же, что и `+` но с умножением
- `/` - то же, что и `+` но с делением
- `//` - то же, что и `+` но с целочисленным деленим
- `/.` - то же, что и `+` но с полученим остатка от деления
- `=` - забрать с СД два числа и сравнить, положить обратно true/false
- `>` - забрать с СД два числа, положить обратно true если первое больше второго, иначе false
- `<` - забрать с СД два числа, положить обратно true если второе больше первого, иначе false
- `[` - продублировать значение на СД (dup)
- `]` - удалить верхнее значение на СД (drop)
- `][` - поменять местами два верхних значения на СД (swap)
- `->` - переложить значенеи с вершины СД на СВ (сдвинуть вправо)
- `<-` - переложить значение с вершины СВ на СД (сдвинуть влево)
- `^` - взять адрес с СВ, перейти по нему (return/goto)
- `;` - тоже что и `^` но служит также маркером конца определения
- `;;` - сдвинуть указатель текущего слвоа на 2 вперед (проигнорировать следующее слово)
- `:` - положить номер следующего слова на стек вызовов, проскипать все слова до `;`
- `@` - опредедить новое слово в словаре. Взять имя с СД и адрес с СВ.
- `!@` - удалить опредление слова из словаря. Взять имя с СД
- `~` - взять с СД имя слова, найти это слово в словаре, положить на СВ адрес этого слова. Если слово отсутствует в словаре или является встроенным, завершить программу.
- `,` - взять текущий адрес, поместить его на СВ
- `!` - взять значение с СД, применить булево отрицание, положить обратно
- `"` - положить следующее слово на СД вне зависимости от того, что это за слово
- `?` - условный переход
	- Взять два адреса с СВ
	- Взять значение с СД
	- Если значение истинно, перейти на первый адрес
	- Иначе на второй

## Execution
Каждый шаг выполнения программы представлен следующим алгоритмом:
- Если указатель текущего слова указывает за пределы текста программы (отрицательный / слишком большой)
	- Завершить выполнение программы
- Получить текущее слово по указателю на него
- Поискать опредление в словаре
- Если слово является числом, если это слово `quotted` или если у этого слова нет отпредления
	- Положить слово на СД
	- Увеличить указатель текущего слова на 1
	- Завершить шаг
- Запомнить значение указателя на текущее слово
- Если слово предопредленное
	- Выполнить связанную функцию
	- Если значение указателя не изменилось, увеличить его на 1
- Иначе
  - Добавить инкрементированное значение указателя на СВ
	- Установить указателю значение, опредленное в словаре
- Завершить шаг

# References
- https://godbolt.org/
- https://playcode.io/new

# Implementation process
Для начала, нужно разбить экран на две области по вертикали.
Нижняя область занимает по высоте ровно столько, сколько нужно чтобы туда влез
ее контент (кнопки, счетчики).
Все пространство над ней занимает верхняя область, которая, в свою очередь
делится по вертикали на три равные панели.

Все вышеописанное должно занимать все пространство экрана ровно.
Т.е. не должно оставаться не занятого места и контент не должен вылезать за
пределы экрана, приводя к появлению полос прокрутки.

Внутри каждой из трех панелей при вылезании контента за доступную область
должен появляться скролл.
Да, отдельный скролл внури каждой панели.
Для самой левой панели скролл доступен и по горизонтали и по вертикалли.
Для остальных двух, только по вертикалли, по горизонтали контент ужимается до доступных размеров (как обычно).

Для левой и правых панелей устанавливается свойство [white-space: pre](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)

Далее поочередно реализуется функционал для панелей с права на лево.
## Right panel
Для нее в JS создается объект `output` инкапсулирующий логику вывода текста.
Он предоставляет следующие методы:
```js
/*
Добавляет в конец содержимого правой панели новый span с указанным текстом
Если в text передано что либо кроме строки, оно приводится к строке.
Текст обязательно экранируется для предотвращения XSS
Все span теги добавленные за вызов print выделяются фоновым цветом.
*/
function print(text) {}

/*
Работает также как и print, но выводит текст красным цветом
*/
function error(text) {}

/*
Убирает выделение цветом со всех span тегов в правой панели.
*/
function unhighlight() {}
```
## Middle panel
Содержит три секции (два отображения стеков, одно отображение словаря) + лейблы
между ними
Т.е. должно быть как то так
```html
<labe>Left stack</labe>
<div></div> <!-- Left stack view -->

<labe>Right stack</labe>
<div></div> <!-- Right stack view -->

<labe>Dictionary</labe>
<div></div> <!-- Dictionary view -->
```
Для обоих стеков логика одинаковая, для словаря отдельная (ваш кеп)

### Stacks view
Для реализации стека нужно создать класс/функцию-конструктор `StackExplorer`.
Для каждого из двух стеков соответвенно по объекту этого класса.

`StackExplorer` инкапсулирует как сам стек и работу с ним, так и вывод
актуального состояния стека в соответствующую секцию.

Класс содержит *приватный* массив, через который и реализуется логика стека.
Вершиной стека является начало массива. Т.е. при добавлении данных на стек,
они добавляются в начало массива, а при удалении, удаляются из начала.

Для каждого элемента стека в соответсвующей секции показывается строчка с
номером элемента от вершины стека (в нашем случае тоже самое что номер в
массиве) и значением приведенным в текст.
```html
<span>NUMBER</span><span>VALUE</span><br>
```

Таким образом для такого стека: `["a", 1000, null, true]` будет такое отображение:
```html
<span>0</span><span>a</span><br>
<span>1</span><span>1000</span><br>
<span>2</span><span>null</span><br>
<span>3</span><span>true</span><br>
```

Естественно, при добавлении на страницу, текст экранируется.

Также `StackExplorer` предоставляет следущие методы:
```js
/*
Кладет value на стек (добавляет в начало массива)
При этом на странице появляется соответствующая строчка

Номера строк на странице изменяются чтобы соответствовать актуальным

Добавленная строчка подсвечивается
*/
function push(value) {}

/*
Забирает верхний элемент стека (0 элемент массива) и возвращает его

Соответствующая строка на странице удаляется
Номера строк обновляются
*/
function pop() {}

/*
Убирает подсвуетку у всех строк
*/
function unhighlight() {}
```

Также конструктор, помимо прочих аргументов, должен принимать в аргумент 
`on_hover` функцию коллбек, которая затем должна вызываться при наведении курсора
на элемент стека на экране:
```js
(value) => {}
```
Где `value` это значение элемента стека под курсором

Когда курсор уходит с элемента, этот же коллбек вызывается еще раз, но с
аргументом `null`

### Dictionary view
Объект `dictionary` инкапсулриует, как саму логику словаря, так и его отображение на странице.

Как уже говорилось выше, словарь, по сути, также явялется стеком и работает
похоже, хотя с ньюансами.

Внутри также есть приватный массив, с которым мы работаем как со стеком.
Однако каждый элемент состоит из трех значений:
- слово
- опредление
- комментарий (может быть пустым)
```json
[
	{"word": "aaaa", "definition": 42, "comment": ""},
	{"word": "E", "definition": () => {}, "comment": "bbbbb"},
]
```
В качестве опредления может быть либо число, либо js функция

Отображение словаря также состоит из вертикального списка с элеманетами.
В нем не отображаются номера элементов, но отображаются `word`, `definition` и
comment.
Если в качестве `definition` указана функция, вместо `definition` отображается
слово `builtin:`
```html
<span>aaaa</span><span>42</span><span></span><br>
<span>E</span><span>builtin:</span><span>bbbbb</span><br>
```

Объект представляет следующие методы:
```js
/*
Добавляет определение в начало словаря (aka push)

Если definition НЕ js функция, пробует привести definition к числу
Если приведение проваливается, кидает ошибку

Добавляет на страницу строчку отображающую новую запись
Новая строчка выделяется цветом

Если в словаре до этого уже были другие опредления того же слова,
соответствующие им строчки делаются полу-прозрачными.
*/
function define(word, definition, comment) {}

/*
Перебирает все элементы словаря от 0 к последнему в поисках опредления слова word
Удаляет первое встреченное опредление и только его
Если в словаре не нашлось определения, кидает ошибку с текстом в духе
"Cannot undefine word with no definitions"
*/
function undefine(word) {}

/*
Перебирает все элементы словаря от 0 к последнему в поисках опредления слова word
Возвращает поле `definition` из первого встреченного опредления
Если в словаре не нашлось определения, возвращает null
*/
function resolve(word) {}

/*
Убирает подсветку у всех строк
*/
function unhighlight() {}
```
`dictionary` также как и `StackExplorer` принимает в конструктор коллбек,
который должен вызывать при наведении курсора на элемент и передавать ему значение
`definition`

## Left panel
На левой панели у нас на самом деле два разных виджета:
- `input` с сырым кодом (текст непосредственно введеный самим юзером)
- Блок в котором будет отрисовываться тот же текст но уже с выделениями и
прочими декорациями после парсинга

В одно и то же время виден только один виджет, а другой скрыт

Пользователь изначально вводин текст в `input`
Затем, после запуска программы, код парсится, нарезается на отдельные слова
и показывается уже через блок. При этом каждое слово обернуто в отдельный
`span`, что позволяет задавать цвет выделения для отдельных слов.

После завершения работы программы, блок со спанами прячется обратно, а `input`,
соответвенно показывается.

Для того, чтобы переключать видимость этих двух виджетов нужны две функции:
```js
function show_input() {}

function show_words() {}
```
Каждая из них соответвенно делает видимыим один виджет и скрывает другой

Btw в обоих виджетах моноширинный шрифт.

Для инпута более никакой допонительной логики не надо.
Для второго виджета также требуется создать объект с логикой.

Внутри себя он должен содержать массив маппингов, в котором хранятся объекты
соовтетвущие span'ам которые создаются на странице.
Это требуется чтобы впоследствии можно было подсвечивать span по его номеру

Методы:
```js
/*
Добавляет текст
Текст экранируется
Если indexable == true, данный эелемент учитывается в массиве маппингов
Если нет то нет
*/
function add(text, indexable) {}

/*
Проверяет что index это
- число
- оно больше 0
- оно меньше длины массива маппингов

Если это не так, метод ничего не делает

Иначе элемент под соответствующим индексом в массиве маппингов подсвечивается цветом
*/
function highlight_color(index) {}

/*
Проверяет что index это
- число
- оно больше 0
- оно меньше длины массива маппингов

Если это не так, метод ничего не делает

Иначе элемент под соответствующим индексом в массиве маппингов обводится рамкой
*/
function highlight_color(index) {}

/*
Убирает любую подсветку у всех элементов
*/
function unhighlight() {}
```

## Parser
Задача функции парсера - преобразовывать исходный текст программы в массив
слов. [См пример выше](#Syntax)

Перед тем как писать парсер, нам потребуется вспомогательная функция:
```js
/*
Если text начинается и кончается одинарной кавычкой (`'`), он должен быть обработан.
Иначе он возвращается как есть.

Обработка заключается в итерации по парам символов с заменой
- `\\` на `\`
- `\'` на `'`
- `\n` на символ переноса строки
*/
function unescape(text) {}
```

Теперь сам парсер

<!--  TODO: -->

## Executor

## Error handling

## Builtin words

## Reset function
```js
/*
Откатывает состояние
*/
function reset() {}
```
